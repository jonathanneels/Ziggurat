/**
 * Generated by the Babylon.JS Editor v4.0.4
 */
import { Scene, Node, SSAO2RenderingPipeline, DefaultRenderingPipeline, ScreenSpaceReflectionPostProcess, MotionBlurPostProcess, Nullable } from "@babylonjs/core";
export declare type NodeScriptConstructor = (new (...args: any[]) => Node);
export declare type GraphScriptConstructor = (new (scene: Scene) => any);
export declare type ScriptMap = {
    [index: string]: {
        IsGraph?: boolean;
        IsGraphAttached?: boolean;
        default: (new (...args: any[]) => NodeScriptConstructor | GraphScriptConstructor);
    };
};
export interface IScript {
    /**
     * Called on the node is being initialized.
     * This function is called immediatly after the constructor has been called.
     */
    onInitialize?(): void;
    /**
     * Called on the scene starts.
     */
    onStart?(): void;
    /**
     * Called each frame.
     */
    onUpdate?(): void;
    /**
     * Called on a message has been received and sent from a graph.
     * @param message defines the name of the message sent from the graph.
     * @param data defines the data sent in the message.
     * @param sender defines the reference to the graph class that sent the message.
     */
    onMessage?(name: string, data: any, sender: any): void;
}
/**
 * Works as an helper, this will:
 * = attach scripts on objects.
 * @param scene the scene to attach scripts, etc.
 */
export declare function runScene(scene: Scene, rootUrl?: string): Promise<void>;
/**
 * Attaches all available scripts on nodes of the given scene.
 * @param scene the scene reference that contains the nodes to attach scripts.
 */
export declare function attachScripts(scriptsMap: ScriptMap, scene: Scene): void;
/**
 * Setups the rendering groups for meshes in the given scene.
 * @param scene defines the scene containing the meshes to configure their rendering group Ids.
 */
export declare function setupRenderingGroups(scene: Scene): void;
/**
 * Meshes using pose matrices with skeletons can't be parsed directly as the pose matrix is
 * missing from the serialzied data of meshes. These matrices are stored in the meshes metadata
 * instead and can be applied by calling this function.
 * @param scene defines the scene containing the meshes to configure their pose matrix.
 */
export declare function applyMeshesPoseMatrices(scene: Scene): void;
/**
 * Attaches the a script at runtime to the given node according to the given script's path.
 * @param scriptPath defines the path to the script to attach (available as a key in the exported "scriptsMap" map).
 * @param object defines the reference to the object (node or scene) to attach the script to.
 */
export declare function attachScriptToNodeAtRuntime(scriptPath: string, object: Node | Scene): any;
/**
 * Defines the reference to the SSAO2 rendering pipeline.
 */
export declare let ssao2RenderingPipelineRef: Nullable<SSAO2RenderingPipeline>;
/**
 * Defines the reference to the SSR post-process.
 */
export declare let screenSpaceReflectionPostProcessRef: Nullable<ScreenSpaceReflectionPostProcess>;
/**
 * Defines the reference to the default rendering pipeline.
 */
export declare let defaultRenderingPipelineRef: Nullable<DefaultRenderingPipeline>;
/**
 * Defines the reference to the motion blur post-process.
 */
export declare let motionBlurPostProcessRef: Nullable<MotionBlurPostProcess>;
/**
 * Configures and attaches the post-processes of the given scene.
 * @param scene the scene where to create the post-processes and attach to its cameras.
 * @param rootUrl the root Url where to find extra assets used by pipelines. Should be the same as the scene.
 */
export declare function configurePostProcesses(scene: Scene, rootUrl?: string): void;
/**
 * @deprecated will be moved to "./decorators.ts".
 */
export * from "./decorators";
